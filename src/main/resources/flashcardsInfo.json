[
  {
    "Title": "Java Introduction",
    "Info": "What is Java?\nJava is a popular programming language, created in 1995.\n\nIt is owned by Oracle, and more than 3 billion devices run Java.\n\nIt is used for:\n- Mobile applications (specially Android apps)\n- Desktop applications\n- Web applications\n- Web servers and application servers\n- Games\n- Database connection\n- And much, much more!\n\nWhy Use Java?\n- Java works on different platforms (Windows, Mac, Linux, Raspberry Pi, etc.)\n- It is one of the most popular programming languages in the world\n- It has a large demand in the current job market\n- It is easy to learn and simple to use\n- It is open-source and free\n- It is secure, fast and powerful\n- It has huge community support (tens of millions of developers)\n- Java is an object oriented language which gives a clear structure to programs and allows code to be reused, lowering development costs\n- As Java is close to C++ and C#, it makes it easy for programmers to switch to Java or vice versa"
  },
  {
    "Title": "Java Syntax",
    "Info": "In the previous chapter, we created a Java file called Main.java, and we used the following code to print \"Hello World\" to the screen:\n\nMain.java\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\nExample explained\nEvery line of code that runs in Java must be inside a class. In our example, we named the class Main. A class should always start with an uppercase first letter.\n\nNote: Java is case-sensitive: \"MyClass\" and \"myclass\" have different meanings.\n\nThe name of the java file must match the class name. When saving the file, save it using the class name and add \".java\" to the end of the filename. To run the example above on your computer, make sure that Java is properly installed: Go to the Get Started Chapter for how to install Java. The output should be:\n\nHello World\n\nThe main Method\nThe main() method is required and you will see it in every Java program:\n\npublic static void main(String[] args)\n\nAny code inside the main() method will be executed. Don't worry about the keywords before and after main. You will get to know them bit by bit while reading this tutorial.\n\nFor now, just remember that every Java program has a class name which must match the filename, and that every program must contain the main() method.\n\nSystem.out.println()\nInside the main() method, we can use the println() method to print a line of text to the screen:\n\npublic static void main(String[] args) {\n  System.out.println(\"Hello World\");\n}"
  },
  {
    "Title": "Java Output / Print",
    "Info": "Print Text\nYou learned from the previous chapter that you can use the println() method to output values or print text in Java:\n\nExample\nSystem.out.println(\"Hello World!\");\n\nYou can add as many println() methods as you want. Note that it will add a new line for each method:\n\nExample\nSystem.out.println(\"Hello World!\");\nSystem.out.println(\"I am learning Java.\");\nSystem.out.println(\"It is awesome!\");\n\nDouble Quotes\nWhen you are working with text, it must be wrapped inside double quotations marks \"\".\n\nIf you forget the double quotes, an error occurs:\n\nExample\nSystem.out.println(\"This sentence will work!\");\nSystem.out.println(This sentence will produce an error);\n\nThe Print() Method\nThere is also a print() method, which is similar to println().\n\nThe only difference is that it does not insert a new line at the end of the output:\n\nExample\nSystem.out.print(\"Hello World! \");\nSystem.out.print(\"I will print on the same line.\");\n\nNote that we add an extra space (after \"Hello World!\" in the example above), for better readability.\n\nIn this tutorial, we will only use println() as it makes it easier to read the output of code."
  },
  {
    "Title": "Print Numbers",
    "Info": "Print Numbers\nYou can also use the println() method to print numbers.\n\nHowever, unlike text, we don't put numbers inside double quotes:\n\nExample\nSystem.out.println(3);\nSystem.out.println(358);\nSystem.out.println(50000);\n\nYou can also perform mathematical calculations inside the println() method:\n\nExample\nSystem.out.println(3 + 3);\n\nExample\nSystem.out.println(2 * 5);"
  },
  {
    "Title": "Java Comments",
    "Info": "Java Comments\nComments can be used to explain Java code, and to make it more readable. It can also be used to prevent execution when testing alternative code.\n\nSingle-line Comments\nSingle-line comments start with two forward slashes (//).\n\nAny text between // and the end of the line is ignored by Java (will not be executed).\n\nThis example uses a single-line comment before a line of code:\n\nExample\n// This is a comment\nSystem.out.println(\"Hello World\");\n\nThis example uses a single-line comment at the end of a line of code:\n\nExample\nSystem.out.println(\"Hello World\"); // This is a comment\n\nJava Multi-line Comments\nMulti-line comments start with /* and ends with */.\n\nAny text between /* and */ will be ignored by Java.\n\nThis example uses a multi-line comment (a comment block) to explain the code:\n\nExample\n/* The code below will print the words Hello World\nto the screen, and it is amazing */\nSystem.out.println(\"Hello World\");\n\nSingle or multi-line comments?\nIt is up to you which you want to use. Normally, we use // for short comments, and /* */ for longer."
  },
  {
    "Title": "Java Variables",
    "Info": "Variables are containers for storing data values.\n\nIn Java, there are different types of variables, for example:\n\n- String - stores text, such as \"Hello\". String values are surrounded by double quotes\n- int - stores integers (whole numbers), without decimals, such as 123 or -123\n- float - stores floating point numbers, with decimals, such as 19.99 or -19.99\n- char - stores single characters, such as 'a' or 'B'. Char values are surrounded by single quotes\n- boolean - stores values with two states: true or false\n\nDeclaring (Creating) Variables\nTo create a variable, you must specify the type and assign it a value:\nSyntax\ntype variableName = value;\n\nWhere type is one of Java's types (such as int or String), and variableName is the name of the variable (such as x or name). The equal sign is used to assign values to the variable.\n\nTo create a variable that should store text, look at the following example:\n\nExample\nCreate a variable called name of type String and assign it the value \"John\":\n\nString name = \"John\";\nSystem.out.println(name);\n\nTo create a variable that should store a number, look at the following example:\n\nExample\nCreate a variable called myNum of type int and assign it the value 15:\n\nint myNum = 15;\nSystem.out.println(myNum);\n\nYou can also declare a variable without assigning the value, and assign the value later:\n\nExample\nint myNum;\nmyNum = 15;\nSystem.out.println(myNum);\n\nNote that if you assign a new value to an existing variable, it will overwrite the previous value:\n\nExample\nChange the value of myNum from 15 to 20:\n\nint myNum = 15;\nmyNum = 20;  // myNum is now 20\nSystem.out.println(myNum);\n\nFinal Variables\nIf you don't want others (or yourself) to overwrite existing values, use the final keyword (this will declare the variable as \"final\" or \"constant\", which means unchangeable and read-only):\n\nExample\nfinal int myNum = 15;\nmyNum = 20;  // will generate an error: cannot assign a value to a final variable\n\nOther Types\nA demonstration of how to declare variables of other types:\n\nExample\nint myNum = 5;\nfloat myFloatNum = 5.99f;\nchar myLetter = 'D';\nboolean myBool = true;\nString myText = \"Hello\";"
  },
  {
    "Title": "Java Print Variables",
    "Info": "Display Variables\nThe println() method is often used to display variables.\n\nTo combine both text and a variable, use the + character:\n\nExample\nString name = \"John\";\nSystem.out.println(\"Hello \" + name);\n\nYou can also use the + character to add a variable to another variable:\n\nExample\nString firstName = \"John \";\nString lastName = \"Doe\";\nString fullName = firstName + lastName;\nSystem.out.println(fullName);\n\nFor numeric values, the + character works as a mathematical operator (notice that we use int (integer) variables here):\n\nExample\nint x = 5;\nint y = 6;\nSystem.out.println(x + y); // Print the value of x + y\n\nFrom the example above, you can expect:\n\nx stores the value 5\ny stores the value 6\nThen we use the println() method to display the value of x + y, which is 11"
  },
  {
    "Title": "Java Declare Multiple Variables",
    "Info": "Declare Many Variables\nTo declare more than one variable of the same type, you can use a comma-separated list:\n\nExample\nInstead of writing:\n\nint x = 5;\nint y = 6;\nint z = 50;\nSystem.out.println(x + y + z);\nYou can simply write:\n\nint x = 5, y = 6, z = 50;\nSystem.out.println(x + y + z);\n\nOne Value to Multiple Variables\nYou can also assign the same value to multiple variables in one line:\n\nExample\nint x, y, z;\nx = y = z = 50;\nSystem.out.println(x + y + z);"
  },
  {
    "Title": "Java Identifiers",
    "Info": "Identifiers\nAll Java variables must be identified with unique names.\n\nThese unique names are called identifiers.\n\nIdentifiers can be short names (like x and y) or more descriptive names (age, sum, totalVolume).\n\nNote: It is recommended to use descriptive names in order to create understandable and maintainable code:\n\nExample\n// Good\nint minutesPerHour = 60;\n\n// OK, but not so easy to understand what m actually is\nint m = 60;\n\nThe general rules for naming variables are:\n\n- Names can contain letters, digits, underscores, and dollar signs\n- Names must begin with a letter\n- Names should start with a lowercase letter, and cannot contain whitespace\n- Names can also begin with $ and _ (but we will not use it in this tutorial)\n- Names are case-sensitive (\"myVar\" and \"myvar\" are different variables)\n- Reserved words (like Java keywords, such as int or boolean) cannot be used as names"
  },
  {
    "Title": "Java Data Types",
    "Info": "As explained in the previous chapter, a variable in Java must be a specified data type:\n\nExample\nint myNum = 5;               // Integer (whole number)\nfloat myFloatNum = 5.99f;    // Floating point number\nchar myLetter = 'D';         // Character\nboolean myBool = true;       // Boolean\nString myText = \"Hello\";     // String\n\nData types are divided into two groups:\n\n- Primitive data types - includes byte, short, int, long, float, double, boolean and char\n- Non-primitive data types - such as String, Arrays and Classes (you will learn more about these in a later chapter)\n\nPrimitive Data Types\nA primitive data type specifies the size and type of variable values, and it has no additional methods.\n\nThere are eight primitive data types in Java:\n\nData Type\tSize\tDescription\nbyte\t1 byte\tStores whole numbers from -128 to 127\nshort\t2 bytes\tStores whole numbers from -32,768 to 32,767\nint\t4 bytes\tStores whole numbers from -2,147,483,648 to 2,147,483,647\nlong\t8 bytes\tStores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\nfloat\t4 bytes\tStores fractional numbers. Sufficient for storing 6 to 7 decimal digits\ndouble\t8 bytes\tStores fractional numbers. Sufficient for storing 15 decimal digits\nboolean\t1 bit\tStores true or false values\nchar\t2 bytes\tStores a single character/letter or ASCII values"
  },
  {
    "Title": "Java Numbers",
    "Info": "Numbers\nPrimitive number types are divided into two groups:\n\n- Integer types store whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are byte, short, int, and long. Which type you should use depends on the numeric value.\n- Floating point types represent numbers with a fractional part, containing one or more decimals. There are two types: float and double.\n\nEven though there are many numeric types in Java, the most used for numbers are int (for whole numbers) and double (for floating point numbers). However, we will describe them all as you continue to read.\n\nInteger Types\nByte\nThe byte data type can store whole numbers from -128 to 127. This can be used instead of int or other integer types to save memory when you are certain that the value will be within -128 and 127:\n\nExample\nbyte myNum = 100;\nSystem.out.println(myNum);\n\nShort\nThe short data type can store whole numbers from -32768 to 32767:\n\nExample\nshort myNum = 5000;\nSystem.out.println(myNum);\n\nInt\nThe int data type can store whole numbers from -2147483648 to 2147483647. In general, and in our tutorial, the int data type is the preferred data type when we create variables with a numeric value.\n\nExample\nint myNum = 100000;\nSystem.out.println(myNum);\n\nLong\nThe long data type can store whole numbers from -9223372036854775808 to 9223372036854775807. This is used when int is not large enough to store the value. Note that you should end the value with an \"L\":\n\nExample\nlong myNum = 15000000000L;\nSystem.out.println(myNum);\n\nFloating Point Types\nYou should use a floating point type whenever you need a number with a decimal, such as 9.99 or 3.14515.\n\nThe float and double data types can store fractional numbers. Note that you should end the value with an \"f\" for floats and \"d\" for doubles:\n\nFloat Example\nfloat myNum = 5.75f;\nSystem.out.println(myNum);\n\nDouble Example\ndouble myNum = 19.99d;\nSystem.out.println(myNum);\n\nUse float or double?\n\nThe precision of a floating point value indicates how many digits the value can have after the decimal point. The precision of float is only six or seven decimal digits, while double variables have a precision of about 15 digits. Therefore it is safer to use double for most calculations.\n\nScientific Numbers\nA floating point number can also be a scientific number with an \"e\" to indicate the power of 10:\n\nExample\nfloat f1 = 35e3f;\ndouble d1 = 12E4d;\nSystem.out.println(f1);\nSystem.out.println(d1);"
  },
  {
    "Title": "Java Boolean Data Types",
    "Info": "Boolean Types\nVery often in programming, you will need a data type that can only have one of two values, like:\n\n- YES / NO\n- ON / OFF\n- TRUE / FALSE\n\nFor this, Java has a boolean data type, which can only take the values true or false:\n\nExample\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false"
  },
  {
    "Title": "Java Characters",
    "Info": "Characters\nThe char data type is used to store a single character. The character must be surrounded by single quotes, like 'A' or 'c':\n\nExample\nchar myGrade = 'B';\nSystem.out.println(myGrade);\n\nAlternatively, if you are familiar with ASCII values, you can use those to display certain characters:\n\nExample\nchar myVar1 = 65, myVar2 = 66, myVar3 = 67;\nSystem.out.println(myVar1);\nSystem.out.println(myVar2);\nSystem.out.println(myVar3);\n\nTip: A list of all ASCII values can be found in our ASCII Table Reference.\n\nStrings\nThe String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:\n\nExample\nString greeting = \"Hello World\";\nSystem.out.println(greeting);"
  },
  {
    "Title": "Java Non-Primitive Data Types",
    "Info": "Non-Primitive Data Types\nNon-primitive data types are called reference types because they refer to objects.\n\nThe main difference between primitive and non-primitive data types are:\n\n- Primitive types are predefined (already defined) in Java. Non-primitive types are created by the programmer and are not defined by Java (except for String).\n- Non-primitive types can be used to call methods to perform certain operations, while primitive types cannot.\n- A primitive type always has a value, while non-primitive types can be null.\n- A primitive type starts with a lowercase letter, while non-primitive types start with an uppercase letter."
  },
  {
    "Title": "Java Operators",
    "Info": "Java Operators\nOperators are used to perform operations on variables and values.\n\nIn the example below, we use the + operator to add together two values:\n\nExample\nint x = 100 + 50;\n\nAlthough the + operator is often used to add together two values, like in the example above, it can also be used to add together a variable and a value, or a variable and another variable:\n\nExample\nint sum1 = 100 + 50;        // 150 (100 + 50)\nint sum2 = sum1 + 250;      // 400 (150 + 250)\nint sum3 = sum2 + sum2;     // 800 (400 + 400)\n\nJava divides the operators into the following groups:\n\n- Arithmetic operators\n- Assignment operators\n- Comparison operators\n- Logical operators\n- Bitwise operators\n\nArithmetic Operators\nArithmetic operators are used to perform common mathematical operations.\n\nOperator\tName\tDescription\tExample\n+ \tAddition\tAdds together two values\tx + y\n- \tSubtraction\tSubtracts one value from another\tx - y\n* \tMultiplication\tMultiplies two values\tx * y\n/ \tDivision\tDivides one value by another\tx / y\n% \tModulus\tReturns the division remainder\tx % y\n++ \tIncrement\tIncreases the value of a variable by 1\t++x\n-- \tDecrement\tDecreases the value of a variable by 1\t--x\n\nJava Assignment Operators\nAssignment operators are used to assign values to variables.\n\nIn the example below, we use the assignment operator (=) to assign the value 10 to a variable called x:\n\nExample\nint x = 10;\n\nThe addition assignment operator (+=) adds a value to a variable:\n\nExample\nint x = 10;\nx += 5;\n\nA list of all assignment operators:\n\nOperator\tExample\tSame As\n= \tx = 5 \tx = 5\n+= \tx += 3 \tx = x + 3\n-= \tx -= 3 \tx = x - 3\n*= \tx *= 3 \tx = x * 3\n/= \tx /= 3 \tx = x / 3\n%= \tx %= 3 \tx = x % 3\n&= \tx &= 3 \tx = x & 3\n|= \tx |= 3 \tx = x | 3\n^= \tx ^= 3 \tx = x ^ 3\n>>= \tx >>= 3 \tx = x >> 3\n<<= \tx <<= 3 \tx = x << 3\n\nJava Comparison Operators\nComparison operators are used to compare two values (or variables). This is important in programming because it helps us to find answers and make decisions.\n\nThe return value of a comparison is either true or false. These values are known as Boolean values, and you will learn more about them in the Booleans and If..Else chapter.\n\nIn the following example, we use the greater than operator (>) to find out if 5 is greater than 3:\n\nExample\nint x = 5;\nint y = 3;\nSystem.out.println(x > y); // returns true, because 5 is higher than 3\n\nOperator\tName\tExample\n== \tEqual to \tx == y\n!= \tNot equal \tx != y\n> \tGreater than \tx > y\n< \tLess than \tx < y\n>= \tGreater than or equal to \tx >= y\n<= \tLess than or equal to \tx <= y\n\nJava Logical Operators\nYou can also test for true or false values with logical operators.\n\nLogical operators are used to determine the logic between variables or values:\n\nOperator\tName\tDescription\tExample\n&&  \tLogical and \tReturns true if both statements are true \tx < 5 &&  x < 10\n||  \tLogical or \tReturns true if one of the statements is true \tx < 5 || x < 4\n! \tLogical not \tReverse the result, returns false if the result is true \t!(x < 5 && x < 10)\n\nTest Yourself With Exercises\nExercise:\nMultiply 10 with 5, and print the result.\n\nSystem.out.println(10 * 5);"
  },
  {
    "Title": "Java Strings",
    "Info": "Java Strings\nStrings are used for storing text.\n\nA String variable contains a collection of characters surrounded by double quotes:\n\nExample\nCreate a variable of type String and assign it a value:\n\nString greeting = \"Hello\";\n\nString Length\nA String in Java is actually an object, which contain methods that can perform certain operations on strings. For example, the length of a string can be found with the length() method:\n\nExample\nString txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nSystem.out.println(\"The length of the txt string is: \" + txt.length());\n\nMore String Methods\nThere are many string methods available, for example toUpperCase() and toLowerCase():\n\nExample\nString txt = \"Hello World\";\nSystem.out.println(txt.toUpperCase());   // Outputs \"HELLO WORLD\"\nSystem.out.println(txt.toLowerCase());   // Outputs \"hello world\"\n\nFinding a Character in a String\nThe indexOf() method returns the index (the position) of the first occurrence of a specified text in a string (including whitespace):\n\nExample\nString txt = \"Please locate where 'locate' occurs!\";\nSystem.out.println(txt.indexOf(\"locate\")); // Outputs 7\n\nJava counts positions from zero.\n0 is the first position in a string, 1 is the second, 2 is the third ...\n\nComplete String Reference\nFor a complete reference of String methods, go to our Java String Methods Reference.\n\nThe reference contains descriptions and examples of all string methods.\n\nTest Yourself With Exercises\nExercise:\nFill in the missing part to create a greeting variable of type String and assign it the value Hello.\n\ngreeting = \"Hello\";"
  },
  {
    "Title": "Java String Concatenation",
    "Info": "String Concatenation\nThe + operator can be used between strings to combine them. This is called concatenation:\n\nExample\nString firstName = \"John\";\nString lastName = \"Doe\";\nSystem.out.println(firstName + \" \" + lastName);\n\nNote that we have added an empty text (\" \") to create a space between firstName and lastName on print.\n\nYou can also use the concat() method to concatenate two strings:\n\nExample\nString firstName = \"John \";\nString lastName = \"Doe\";\nSystem.out.println(firstName.concat(lastName));"
  },
  {
    "Title": "Java Booleans",
    "Info": "Java Booleans\nVery often, in programming, you will need a data type that can only have one of two values, like:\n\n- YES / NO\n- ON / OFF\n- TRUE / FALSE\n\nFor this, Java has a boolean data type, which can store true or false values.\n\nBoolean Values\nA boolean type is declared with the boolean keyword and can only take the values true or false:\n\nExample\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false\n\nHowever, it is more common to return boolean values from boolean expressions, for conditional testing (see below).\n\nBoolean Expression\nA Boolean expression returns a boolean value: true or false.\n\nThis is useful to build logic, and find answers.\n\nFor example, you can use a comparison operator, such as the greater than (>) operator, to find out if an expression (or a variable) is true or false:\n\nExample\nint x = 10;\nint y = 9;\nSystem.out.println(x > y); // returns true, because 10 is higher than 9\n\nOr even easier:\n\nExample\nSystem.out.println(10 > 9); // returns true, because 10 is higher than 9\n\nIn the examples below, we use the equal to (==) operator to evaluate an expression:\n\nExample\nint x = 10;\nSystem.out.println(x == 10); // returns true, because the value of x is equal to 10\n\nExample\nSystem.out.println(10 == 15); // returns false, because 10 is not equal to 15\n\nReal Life Example\nLet's think of a \"real life example\" where we need to find out if a person is old enough to vote.\n\nIn the example below, we use the >= comparison operator to find out if the age (25) is greater than OR equal to the voting age limit, which is set to 18:\n\nExample\nint myAge = 25;\nint votingAge = 18;\nSystem.out.println(myAge >= votingAge);\n\nCool, right? An even better approach (since we are on a roll now), would be to wrap the code above in an if...else statement, so we can perform different actions depending on the result:\n\nExample\nOutput \"Old enough to vote!\" if myAge is greater than or equal to 18. Otherwise output \"Not old enough to vote.\":\n\nint myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\n  System.out.println(\"Old enough to vote!\");\n} else {\n  System.out.println(\"Not old enough to vote.\");\n}\n\nBooleans are the basis for all Java comparisons and conditions.\n\nYou will learn more about conditions (if...else) in the next chapter."
  },
  {
    "Title": "Java If ... Else",
    "Info": "Java Conditions and If Statements\nYou already know that Java supports the usual logical conditions from mathematics:\n\n- Less than: a < b\n- Less than or equal to: a <= b\n- Greater than: a > b\n- Greater than or equal to: a >= b\n- Equal to: a == b\n- Not Equal to: a != b\n\nYou can use these conditions to perform different actions for different decisions.\n\nJava has the following conditional statements:\n\n- Use if to specify a block of code to be executed, if a specified condition is true\n- Use else to specify a block of code to be executed, if the same condition is false\n- Use else if to specify a new condition to test, if the first condition is false\n- Use switch to specify many alternative blocks of code to be executed\n\nThe if Statement\nUse the if statement to specify a block of Java code to be executed if a condition is true.\n\nSyntax\nif (condition) {\n  // block of code to be executed if the condition is true\n}\n\nNote that if is in lowercase letters. Uppercase letters (If or IF) will generate an error.\n\nIn the example below, we test two values to find out if 20 is greater than 18. If the condition is true, print some text:\n\nExample\nif (20 > 18) {\n  System.out.println(\"20 is greater than 18\");\n}\n\nWe can also test variables:\n\nExample\nint x = 20;\nint y = 18;\nif (x > y) {\n  System.out.println(\"x is greater than y\");\n}\n\nExample explained\nIn the example above we use two variables, x and y, to test whether x is greater than y (using the > operator). As x is 20, and y is 18, and we know that 20 is greater than 18, we print to the screen that \"x is greater than y\"."
  },
  {
    "Title": "Java Else",
    "Info": "The else Statement\nUse the else statement to specify a block of code to be executed if the condition is false.\n\nSyntax\nif (condition) {\n  // block of code to be executed if the condition is true\n} else {\n  // block of code to be executed if the condition is false\n}\n\nExample\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nExample explained\nIn the example above, time (20) is greater than 18, so the condition is false. Because of this, we move on to the else condition and print to the screen \"Good evening\". If the time was less than 18, the program would print \"Good day\"."
  },
  {
    "Title": "Java Else If",
    "Info": "The else if Statement\nUse the else if statement to specify a new condition if the first condition is false.\n\nSyntax\nif (condition1) {\n  // block of code to be executed if condition1 is true\n} else if (condition2) {\n  // block of code to be executed if the condition1 is false and condition2 is true\n} else {\n  // block of code to be executed if the condition1 is false and condition2 is false\n}\n\nExample\nint time = 22;\nif (time < 10) {\n  System.out.println(\"Good morning.\");\n} else if (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nExample explained\nIn the example above, time (22) is greater than 10, so the first condition is false. The next condition, in the else if statement, is also false, so we move on to the else condition since condition1 and condition2 are both false - and print to the screen \"Good evening\".\n\nHowever, if the time was 14, our program would print \"Good day.\""
  },
  {
    "Title": "Java Switch",
    "Info": "Java Switch Statements\nInstead of writing many if..else statements, you can use the switch statement.\n\nThe switch statement selects one of many code blocks to be executed:\n\nSyntax\nswitch(expression) {\n  case x:\n    // code block\n    break;\n  case y:\n    // code block\n    break;\n  default:\n    // code block\n}\n\nThis is how it works:\n\n- The switch expression is evaluated once.\n- The value of the expression is compared with the values of each case.\n- If there is a match, the associated block of code is executed.\n- The break and default keywords are optional, and will be described later in this chapter.\n\nThe example below uses the weekday number to calculate the weekday name:\n\nExample\nint day = 4;\nswitch (day) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  case 2:\n    System.out.println(\"Tuesday\");\n    break;\n  case 3:\n    System.out.println(\"Wednesday\");\n    break;\n  case 4:\n    System.out.println(\"Thursday\");\n    break;\n  case 5:\n    System.out.println(\"Friday\");\n    break;\n  case 6:\n    System.out.println(\"Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Sunday\");\n    break;\n}\n// Outputs \"Thursday\" (day 4)\n\nThe break Keyword\nWhen Java reaches a break keyword, it breaks out of the switch block.\n\nThis will stop the execution of more code and case testing inside the block.\n\nWhen a match is found, and the job is done, it's time for a break. There is no need for more testing.\n\nA break can save a lot of execution time because it \"ignores\" the execution of all the rest of the code in the switch block.\n\nThe default Keyword\nThe default keyword specifies some code to run if there is no case match:\n\nExample\nint day = 4;\nswitch (day) {\n  case 6:\n    System.out.println(\"Today is Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Today is Sunday\");\n    break;\n  default:\n    System.out.println(\"Looking forward to the Weekend\");\n}\n// Outputs \"Looking forward to the Weekend\"\n\nNote that if the default statement is used as the last statement in a switch block, it does not need a break."
  },
  {
    "Title": "Java While Loop",
    "Info": "Loops\nLoops can execute a block of code as long as a specified condition is reached.\n\nLoops are handy because they save time, reduce errors, and they make code more readable.\n\nJava While Loop\nThe while loop loops through a block of code as long as a specified condition is true:\n\nSyntax\nwhile (condition) {\n  // code block to be executed\n}\n\nIn the example below, the code in the loop will run, over and over again, as long as a variable (i) is less than 5:\n\nExample\nint i = 0;\nwhile (i < 5) {\n  System.out.println(i);\n  i++;\n}\n\nNote: Do not forget to increase the variable used in the condition, otherwise the loop will never end!"
  },
  {
    "Title": "Java Do/While Loop",
    "Info": "The Do/While Loop\nThe do/while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true, then it will repeat the loop as long as the condition is true.\n\nSyntax\ndo {\n  // code block to be executed\n}\nwhile (condition);\n\nThe example below uses a do/while loop. The loop will always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested:\n\nExample\nint i = 0;\ndo {\n  System.out.println(i);\n  i++;\n}\nwhile (i < 5);\n\nDo not forget to increase the variable used in the condition, otherwise the loop will never end!"
  },
  {
    "Title": "Java For Loop",
    "Info": "Java For Loop\nWhen you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop:\n\nSyntax\nfor (statement 1; statement 2; statement 3) {\n  // code block to be executed\n}\n\nStatement 1 is executed (one time) before the execution of the code block.\n\nStatement 2 defines the condition for executing the code block.\n\nStatement 3 is executed (every time) after the code block has been executed.\n\nThe example below will print the numbers 0 to 4:\n\nExample\nfor (int i = 0; i < 5; i++) {\n  System.out.println(i);\n}\n\nExample explained\nStatement 1 sets a variable before the loop starts (int i = 0).\n\nStatement 2 defines the condition for the loop to run (i must be less than 5). If the condition is true, the loop will start over again, if it is false, the loop will end.\n\nStatement 3 increases a value (i++) each time the code block in the loop has been executed.\n\nAnother Example\nThis example will only print even values between 0 and 10:\n\nExample\nfor (int i = 0; i <= 10; i = i + 2) {\n  System.out.println(i);\n}\n\nTest Yourself With Exercises\nExercise:\nUse a for loop to print \"Yes\" 5 times.\n\nfor (int i = 0; i < 5; i++) {\n  System.out.println(\"Yes\");\n}\n\nJava Nested Loops\nNested Loops\nIt is also possible to place a loop inside another loop. This is called a nested loop.\n\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":\n\nExample\n// Outer loop\nfor (int i = 1; i <= 2; i++) {\n  System.out.println(\"Outer: \" + i); // Executes 2 times\n  \n  // Inner loop\n  for (int j = 1; j <= 3; j++) {\n    System.out.println(\" Inner: \" + j); // Executes 6 times (2 * 3)\n  }\n}\n\nFor-Each Loop\nThere is also a \"for-each\" loop, which is used exclusively to loop through elements in an array:\n\nSyntax\nfor (type variableName : arrayName) {\n  // code block to be executed\n}\n\nThe following example outputs all elements in the cars array, using a \"for-each\" loop:\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}"
  },
  {
    "Title": "Java Break and Continue",
    "Info": "Java Break\nYou have already seen the break statement used in an earlier chapter of this tutorial. It was used to \"jump out\" of a switch statement.\n\nThe break statement can also be used to jump out of a loop.\n\nThis example stops the loop when i is equal to 4:\n\nExample\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    break;\n  }\n  System.out.println(i);\n}\n\nJava Continue\nThe continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.\n\nThis example skips the value of 4:\n\nExample\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    continue;\n  }\n  System.out.println(i);\n}\n\nBreak and Continue in While Loop\nYou can also use break and continue in while loops:\n\nBreak Example\nint i = 0;\nwhile (i < 10) {\n  System.out.println(i);\n  i++;\n  if (i == 4) {\n    break;\n  }\n}\n\nContinue Example\nint i = 0;\nwhile (i < 10) {\n  if (i == 4) {\n    i++;\n    continue;\n  }\n  System.out.println(i);\n  i++;\n}"
  },
  {
    "Title": "Java Arrays",
    "Info": "Java Arrays\nArrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.\n\nTo declare an array, define the variable type with square brackets:\n\nString[] cars;\n\nWe have now declared a variable that holds an array of strings. To insert values to it, you can place the values in a comma-separated list, inside curly braces:\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nTo create an array of integers, you could write:\n\nint[] myNum = {10, 20, 30, 40};\n\nAccess the Elements of an Array\nYou can access an array element by referring to the index number.\n\nThis statement accesses the value of the first element in cars:\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars[0]);\n// Outputs Volvo\n\nNote: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\n\nChange an Array Element\nTo change the value of a specific element, refer to the index number:\n\nExample\ncars[0] = \"Opel\";\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\ncars[0] = \"Opel\";\nSystem.out.println(cars[0]);\n// Now outputs Opel instead of Volvo\n\nArray Length\nTo find out how many elements an array has, use the length property:\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars.length);\n// Outputs 4\n\nJava Arrays Loop\nLoop Through an Array\nYou can loop through the array elements with the for loop, and use the length property to specify how many times the loop should run.\n\nThe following example outputs all elements in the cars array:\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (int i = 0; i < cars.length; i++) {\n  System.out.println(cars[i]);\n}\n\nLoop Through an Array with For-Each\nThere is also a \"for-each\" loop, which is used exclusively to loop through elements in arrays:\n\nSyntax\nfor (type variable : arrayname) {\n  ...\n}\n\nThe following example outputs all elements in the cars array, using a \"for-each\" loop:\n\nExample\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}\n\nThe example above can be read like this: for each String element (called i - as in index) in cars, print out the value of i.\n\nIf you compare the for loop and for-each loop, you will see that the for-each method is easier to write, it does not require a counter (using the length property), and it is more readable.\n\nReal-Life Example\nTo demonstrate a practical example of using arrays, let's create a program that calculates the average of different ages:\n\nExample\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Loop through the elements of the array\nfor (int age : ages) {\n  sum += age;\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nSystem.out.println(\"The average age is: \" + avg);\n\nAnd in this example, we create a program that finds the lowest age among different ages:\n\nExample\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Create a 'lowest age' variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int age : ages) {\n  // Check if the current age is smaller than the current 'lowest age'\n  if (lowestAge > age) {\n    // If the smaller age is found, update 'lowest age' with that element\n    lowestAge = age;\n  }\n}\n\n// Output the value of the lowest age\nSystem.out.println(\"The lowest age in the array is: \" + lowestAge);"
  },
  {
    "Title": "Java OOP",
    "Info": "Java - What is OOP?\nOOP stands for Object-Oriented Programming.\n\nProcedural programming is about writing procedures or methods that perform operations on the data, while object-oriented programming is about creating objects that contain both data and methods.\n\nObject-oriented programming has several advantages over procedural programming:\n\nOOP is faster and easier to execute\nOOP provides a clear structure for the programs\nOOP helps to keep the Java code DRY \"Don't Repeat Yourself\", and makes the code easier to maintain, modify and debug\nOOP makes it possible to create full reusable applications with less code and shorter development time\nTip: The \"Don't Repeat Yourself\" (DRY) principle is about reducing the repetition of code. You should extract out the codes that are common for the application, and place them at a single place and reuse them instead of repeating it.\n\nJava - What are Classes and Objects?\nClasses and objects are the two main aspects of object-oriented programming.\n\nLook at the following illustration to see the difference between class and objects:\n\nclass\nFruit\n\nobjects\nApple\n\nBanana\n\nMango\n\nAnother example:\n\nclass\nCar\n\nobjects\nVolvo\n\nAudi\n\nToyota\n\nSo, a class is a template for objects, and an object is an instance of a class.\n\nWhen the individual objects are created, they inherit all the variables and methods from the class.\n\nYou will learn much more about classes and objects in the next chapter."
  },
  {
    "Title": "Java Classes and Objects",
    "Info": "Java Classes/Objects\nJava is an object-oriented programming language.\n\nEverything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nCreate a Class\nTo create a class, use the keyword class:\n\nMain.java\nCreate a class named \"Main\" with a variable x:\n\npublic class Main {\n  int x = 5;\n}\nRemember from the Java Syntax chapter that a class should always start with an uppercase first letter, and that the name of the java file should match the class name.\n\nCreate an Object\nIn Java, an object is created from a class. We have already created the class named Main, so now we can use this to create objects.\n\nTo create an object of Main, specify the class name, followed by the object name, and use the keyword new:\n\nExample\nCreate an object called \"myObj\" and print the value of x:\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}"
  },
  {
    "Title": "Accessing Attributes",
    "Info": "You can access attributes by creating an object of the class, and by using the dot syntax (.):\n\nThe following example will create an object of the Main class, with the name myObj. We use the x attribute on the object to print its value:\n\nExample\nCreate an object called \"myObj\" and print the value of x:\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\n\nModify Attributes\nYou can also modify attribute values:\n\nExample\nSet the value of x to 40:\n\npublic class Main {\n  int x;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 40;\n    System.out.println(myObj.x);\n  }\n}\n\nOr override existing values:\n\nExample\nChange the value of x to 25:\n\npublic class Main {\n  int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // x is now 25\n    System.out.println(myObj.x);\n  }\n}\n\nIf you don't want the ability to override existing values, declare the attribute as final:\n\nExample\npublic class Main {\n  final int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}"
  },
  {
    "Title": "Java Class Methods",
    "Info": "Java Class Methods\nYou learned from the Java Methods chapter that methods are declared within a class, and that they are used to perform certain actions:\n\nExample\nCreate a method named myMethod() in Main:\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n}\n\nmyMethod() prints a text (the action), when it is called. To call a method, write the method's name followed by two parentheses () and a semicolon;\n\nExample\nInside main, call myMethod():\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"Hello World!\"\n\n\nStatic vs. Public\nYou will often see Java programs that have either static or public attributes and methods.\n\nIn the example above, we created a static method, which means that it can be accessed without creating an object of the class, unlike public, which can only be accessed by objects:\n\nExample\nAn example to demonstrate the differences between static and public methods:\n\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would compile an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method on the object\n  }\n}"
  },
  {
    "Title": "Java Constructors",
    "Info": "Java Constructors\nA constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object attributes:\n\nExample\nCreate a constructor:\n\n// Create a Main class\npublic class Main {\n  int x;  // Create a class attribute\n\n  // Create a class constructor for the Main class\n  public Main() {\n    x = 5;  // Set the initial value for the class attribute x\n  }\n\n  public static void main(String[] args) {\n    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)\n    System.out.println(myObj.x); // Print the value of x\n  }\n}\n\n// Outputs 5"
  },
  {
    "Title": "Java Modifiers",
    "Info": "Modifiers\nBy now, you are quite familiar with the public keyword that appears in almost all of our examples:\n\npublic class Main\nThe public keyword is an access modifier, meaning that it is used to set the access level for classes, attributes, methods and constructors.\n\nWe divide modifiers into two groups:\n\nAccess Modifiers - controls the access level\nNon-Access Modifiers - do not control access level, but provides other functionality\n\nAccess Modifiers\nFor classes, you can use either public or default:\n\nModifier\tDescription\npublic\tThe class is accessible by any other class\ndefault\tThe class is only accessible by classes in the same package. This is used when you don't specify a modifier. You will learn more about packages in the Packages chapter\n\nFor attributes, methods and constructors, you can use one of the following:\n\nModifier\tDescription\npublic\tThe code is accessible for all classes\nprivate\tThe code is only accessible within the declared class\ndefault\tThe code is only accessible in the same package. This is used when you don't specify a modifier. You will learn more about packages in the Packages chapter\nprotected\tThe code is accessible in the same package and subclasses. You will learn more about subclasses and superclasses in the Inheritance chapter\n\nNon-Access Modifiers\nFor classes, you can use either final or abstract:\n\nModifier\tDescription\nfinal\tThe class cannot be inherited by other classes (You will learn more about inheritance in the Inheritance chapter)\nabstract\tThe class cannot be used to create objects (To access an abstract class, it must be inherited from another class. You will learn more about inheritance and abstraction in the Inheritance and Abstraction chapters)\n\nFor attributes and methods, you can use one of the following:\n\nModifier\tDescription\nfinal\tAttributes and methods cannot be overridden/modified\nstatic\tAttributes and methods belongs to the class, rather than an object\nabstract\tCan only be used in an abstract class, and can only be used on methods. The method does not have a body, for example abstract void run();. The body is provided by the subclass (inherited from). You will learn more about inheritance and abstraction in the Inheritance and Abstraction chapters\ntransient\tAttributes and methods are skipped when serializing the object containing them\nsynchronized\tMethods can only be accessed by one thread at a time\nvolatile\tThe value of an attribute is not cached thread-locally, and is always read from the \"main memory\"\n\nFinal\nIf you don't want the ability to override existing attribute values, declare attributes as final:\n\nExample\npublic class Main {\n  final int x = 10;\n  final double PI = 3.14;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 50; // will generate an error: cannot assign a value to a final variable\n    myObj.PI = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}\n\n\nStatic\nA static method means that it can be accessed without creating an object of the class, unlike public:\n\nExample\nAn example to demonstrate the differences between static and public methods:\n\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would output an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method\n  }\n}\n\n\nAbstract\nAn abstract method belongs to an abstract class, and it does not have a body. The body is provided by the subclass:\n\nExample\n// Code from filename: Main.java\n// abstract class\nabstract class Main {\n  public String fname = \"John\";\n  public int age = 24;\n  public abstract void study(); // abstract method\n}\n\n// Subclass (inherit from Main)\nclass Student extends Main {\n  public int graduationYear = 2018;\n  public void study() { // the body of the abstract method is provided here\n    System.out.println(\"Studying all day long\");\n  }\n}\n// End code from filename: Main.java\n\n// Code from filename: Second.java\nclass Second {\n  public static void main(String[] args) {\n    // create an object of the Student class (which inherits attributes and methods from Main)\n    Student myObj = new Student();\n\n    System.out.println(\"Name: \" + myObj.fname);\n    System.out.println(\"Age: \" + myObj.age);\n    System.out.println(\"Graduation Year: \" + myObj.graduationYear);\n    myObj.study(); // call abstract method\n  }\n}"
  },
  {
    "Title": "Java Encapsulation",
    "Info": "Encapsulation\nThe meaning of Encapsulation, is to make sure that \"sensitive\" data is hidden from users. To achieve this, you must:\n\n- declare class variables/attributes as private\n- provide public get and set methods to access and update the value of a private variable\n\nGet and Set\nYou learned from the previous chapter that private variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.\n\nThe get method returns the variable value, and the set method sets the value.\n\nSyntax for both is that they start with either get or set, followed by the name of the variable, with the first letter in upper case:\n\nExample\npublic class Person {\n  private String name; // private = restricted access\n\n  // Getter\n  public String getName() {\n    return name;\n  }\n\n  // Setter\n  public void setName(String newName) {\n    this.name = newName;\n  }\n}\n\n\nExample explained\nThe get method returns the value of the variable name.\n\nThe set method takes a parameter (newName) and assigns it to the name variable. The this keyword is used to refer to the current object.\n\nHowever, as the name variable is declared as private, we cannot access it from outside this class:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.name = \"John\";  // error\n    System.out.println(myObj.name); // error\n  }\n}\n\nIf the variable was declared as public, we would expect the following output:\n\nJohn\nHowever, as we try to access a private variable, we get an error:\n\nMyClass.java:4: error: name has private access in Person\n    myObj.name = \"John\";\n         ^\nMyClass.java:5: error: name has private access in Person\n    System.out.println(myObj.name);\n                  ^\n2 errors\nInstead, we use the getName() and setName() methods to access and update the variable:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.setName(\"John\"); // Set the value of the name variable to \"John\"\n    System.out.println(myObj.getName());\n  }\n}\n\n// Outputs \"John\"\n\n\nWhy Encapsulation?\n- Better control of class attributes and methods\n- Class attributes can be made read-only (if you only use the get method), or write-only (if you only use the set method)\n- Flexible: the programmer can change one part of the code without affecting other parts\n- Increased security of data"
  },
  {
    "Title": "Java Packages",
    "Info": "Java Packages & API\nA package in Java is used to group related classes. Think of it as a folder in a file directory. We use packages to avoid name conflicts, and to write a better maintainable code. Packages are divided into two categories:\n\n- Built-in Packages (packages from the Java API)\n- User-defined Packages (create your own packages)\n\nBuilt-in Packages\nThe Java API is a library of prewritten classes, that are free to use, included in the Java Development Environment.\n\nThe library contains components for managing input, database programming, and much much more. The complete list can be found at Oracles website: https://docs.oracle.com/javase/8/docs/api/.\n\nThe library is divided into packages and classes. Meaning you can either import a single class (along with its methods and attributes), or a whole package that contain all the classes that belong to the specified package.\n\nTo use a class or a package from the library, you need to use the import keyword:\n\nSyntax\nimport package.name.Class;   // Import a single class\nimport package.name.*;   // Import the whole package\n\nImport a Class\nIf you find a class you want to use, for example, the Scanner class, which is used to get user input, write the following code:\n\nExample\nimport java.util.Scanner;\nIn the example above, java.util is a package, while Scanner is a class of the java.util package.\n\nTo use the Scanner class, create an object of the class and use any of the available methods found in the Scanner class documentation. In our example, we will use the nextLine() method, which is used to read a complete line:\n\nExample\nUsing the Scanner class to get user input:\n\nimport java.util.Scanner;\n\nclass MyClass {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();\n    System.out.println(\"Username is: \" + userName);\n  }\n}\n\nImport a Package\nThere are many packages to choose from. In the previous example, we used the Scanner class from the java.util package. This package also contains date and time facilities, random-number generator and other utility classes.\n\nTo import a whole package, end the sentence with an asterisk sign (*). The following example will import ALL the classes in the java.util package:\n\nExample\nimport java.util.*;\n\nUser-defined Packages\nTo create your own package, you need to understand that Java uses a file system directory to store them. Just like folders on your computer:\n\nExample\n└── root\n  └── mypack\n    └── MyPackageClass.java\n\nTo create a package, use the package keyword:\n\nMyPackageClass.java\npackage mypack;\nclass MyPackageClass {\n  public static void main(String[] args) {\n    System.out.println(\"This is my package!\");\n  }\n}\n\nSave the file as MyPackageClass.java, and compile it:\n\nC:\\Users\\Your Name>javac MyPackageClass.java\nThen compile the package:\n\nC:\\Users\\Your Name>javac -d . MyPackageClass.java\nThis forces the compiler to create the \"mypack\" package.\n\nThe -d keyword specifies the destination for where to save the class file. You can use any directory name, like c:/user (windows), or, if you want to keep the package within the same directory, you can use the dot sign \".\", like in the example above.\n\nNote: The package name should be written in lower case to avoid conflict with class names.\n\nWhen we compiled the package in the example above, a new folder was created, called \"mypack\".\n\nTo run the MyPackageClass.java file, write the following:\n\nC:\\Users\\Your Name>java mypack.MyPackageClass\nThe output will be:\n\nThis is my package!"
  },
  {
    "Title": "Java Polymorphism",
    "Info": "Java Polymorphism\nPolymorphism means \"many forms\", and it occurs when we have many classes that are related to each other by inheritance.\n\nLike we specified in the previous chapter; Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways.\n\nFor example, think of a superclass called Animal that has a method called animalSound(). Subclasses of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.):\n\nExample\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\nRemember from the Inheritance chapter that we use the extends keyword to inherit from a class.\n\nNow we can create Pig and Dog objects and call the animalSound() method on both of them:\n\nExample\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Animal myAnimal = new Animal();  // Create a Animal object\n    Animal myPig = new Pig();  // Create a Pig object\n    Animal myDog = new Dog();  // Create a Dog object\n    myAnimal.animalSound();\n    myPig.animalSound();\n    myDog.animalSound();\n  }\n}\n\nWhy And When To Use \"Inheritance\" and \"Polymorphism\"?\n- It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class."
  },
  {
    "Title": "Java Inner Classes",
    "Info": "Java Inner Classes\nIn Java, it is also possible to nest classes (a class within a class). The purpose of nested classes is to group classes that belong together, which makes your code more readable and maintainable.\n\nTo access the inner class, create an object of the outer class, and then create an object of the inner class:\n\nExample\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\n// Outputs 15 (5 + 10)\n\n\nPrivate Inner Class\nUnlike a \"regular\" class, an inner class can be private or protected. If you don't want outside objects to access the inner class, declare the class as private:\n\nExample\nclass OuterClass {\n  int x = 10;\n\n  private class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\nIf you try to access a private inner class from an outside class, an error occurs:\n\nMain.java:13: error: OuterClass.InnerClass has private access in OuterClass\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n              ^\n\nStatic Inner Class\nAn inner class can also be static, which means that you can access it without creating an object of the outer class:\n\nExample\nclass OuterClass {\n  int x = 10;\n\n  static class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass.InnerClass myInner = new OuterClass.InnerClass();\n    System.out.println(myInner.y);\n  }\n}\n\n// Outputs 5\n\n\nNote: just like static attributes and methods, a static inner class does not have access to members of the outer class.\n\nAccess Outer Class From Inner Class\nOne advantage of inner classes, is that they can access attributes and methods of the outer class:\n\nExample\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    public int myInnerMethod() {\n      return x;\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.myInnerMethod());\n  }\n}\n\n// Outputs 10"
  },
  {
    "Title": "Java Abstraction",
    "Info": "Abstract Classes and Methods\nData abstraction is the process of hiding certain details and showing only essential information to the user. Abstraction can be achieved with either abstract classes or interfaces (which you will learn more about in the next chapter).\n\nThe abstract keyword is a non-access modifier, used for classes and methods:\n\n- Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).\n\n- Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from). An abstract class can have both abstract and regular methods:\n\nabstract class Animal {\n  public abstract void animalSound();\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\nFrom the example above, it is not possible to create an object of the Animal class:\n\nAnimal myObj = new Animal(); // will generate an error\nTo access the abstract class, it must be inherited from another class. Let's convert the Animal class we used in the Polymorphism chapter to an abstract class:\n\nRemember from the Inheritance chapter that we use the extends keyword to inherit from a class.\n\nExample\n// Abstract class\nabstract class Animal {\n  // Abstract method (does not have a body)\n  public abstract void animalSound();\n  // Regular method\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\n// Subclass (inherit from Animal)\nclass Pig extends Animal {\n  public void animalSound() {\n    // The body of animalSound() is provided here\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Pig myPig = new Pig(); // Create a Pig object\n    myPig.animalSound();\n    myPig.sleep();\n  }\n}\n\n\nWhy And When To Use Abstract Classes and Methods?\n- To achieve security - hide certain details and only show the important details of an object.\n\nNote: Abstraction can also be achieved with Interfaces, which you will learn more about in the next chapter."
  },
  {
    "Title": "Java Enums",
    "Info": "Enums\nAn enum is a special \"class\" that represents a group of constants (unchangeable variables, like final variables).\n\nTo create an enum, use the enum keyword (instead of class or interface), and separate the constants with a comma. Note that they should be in uppercase letters:\n\nExample\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\nYou can access enum constants with the dot syntax:\n\nLevel myVar = Level.MEDIUM;\nEnum is short for \"enumerations\", which means \"specifically listed\".\n\nEnum inside a Class\nYou can also have an enum inside a class:\n\nExample\npublic class Main {\n  enum Level {\n    LOW,\n    MEDIUM,\n    HIGH\n  }\n\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM; \n    System.out.println(myVar);\n  }\n}\nThe output will be:\n\nMEDIUM\n\nEnum in a Switch Statement\nEnums are often used in switch statements to check for corresponding values:\n\nExample\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM;\n\n    switch(myVar) {\n      case LOW:\n        System.out.println(\"Low level\");\n        break;\n      case MEDIUM:\n         System.out.println(\"Medium level\");\n        break;\n      case HIGH:\n        System.out.println(\"High level\");\n        break;\n    }\n  }\n}\nThe output will be:\n\nMedium level\n\nLoop Through an Enum\nThe enum type has a values() method, which returns an array of all enum constants. This method is useful when you want to loop through the constants of an enum:\n\nExample\nfor (Level myVar : Level.values()) {\n  System.out.println(myVar);\n}\nThe output will be:\n\nLOW\nMEDIUM\nHIGH\n\nDifference between Enums and Classes\nAn enum can, just like a class, have attributes and methods. The only difference is that enum constants are public, static and final (unchangeable - cannot be overridden).\n\nAn enum cannot be used to create objects, and it cannot extend other classes (but it can implement interfaces).\n\nWhy And When To Use Enums?\nUse enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc."
  },
  {
    "Title": "Java User Input",
    "Info": "Java User Input\nThe Scanner class is used to get user input, and it is found in the java.util package.\n\nTo use the Scanner class, create an object of the class and use any of the available methods found in the Scanner class documentation. In our example, we will use the nextLine() method, which is used to read Strings:\n\nExample\nimport java.util.Scanner;  // Import the Scanner class\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);  // Create a Scanner object\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();  // Read user input\n    System.out.println(\"Username is: \" + userName);  // Output user input\n  }\n}\n\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nInput Types\nIn the example above, we used the nextLine() method, which is used to read Strings. To read other types, look at the table below:\n\nMethod\tDescription\nnextBoolean()\tReads a boolean value from the user\nnextByte()\tReads a byte value from the user\nnextDouble()\tReads a double value from the user\nnextFloat()\tReads a float value from the user\nnextInt()\tReads a int value from the user\nnextLine()\tReads a String value from the user\nnextLong()\tReads a long value from the user\nnextShort()\tReads a short value from the user\nIn the example below, we use different methods to read data of various types:\n\nExample\nimport java.util.Scanner;\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n\n    System.out.println(\"Enter name, age and salary:\");\n\n    // String input\n    String name = myObj.nextLine();\n\n    // Numerical input\n    int age = myObj.nextInt();\n    double salary = myObj.nextDouble();\n\n    // Output input by user\n    System.out.println(\"Name: \" + name);\n    System.out.println(\"Age: \" + age);\n    System.out.println(\"Salary: \" + salary);\n  }\n}\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\").\n\nYou can read more about exceptions and how to handle errors in the Exceptions chapter."
  },
  {
    "Title": "Java Date and Time",
    "Info": "Java Dates\nJava does not have a built-in Date class, but we can import the java.time package to work with the date and time API. The package includes many date and time classes. For example:\n\nClass\tDescription\nLocalDate\tRepresents a date (year, month, day (yyyy-MM-dd))\nLocalTime\tRepresents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))\nLocalDateTime\tRepresents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)\nDateTimeFormatter\tFormatter for displaying and parsing date-time objects\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nDisplay Current Date\nTo display the current date, import the java.time.LocalDate class, and use its now() method:\n\nExample\nimport java.time.LocalDate; // import the LocalDate class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDate myObj = LocalDate.now(); // Create a date object\n    System.out.println(myObj); // Display the current date\n  }\n}\nThe output will be:\n\n2024-05-19\n\nDisplay Current Time\nTo display the current time (hour, minute, second, and nanoseconds), import the java.time.LocalTime class, and use its now() method:\n\nExample\nimport java.time.LocalTime; // import the LocalTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalTime myObj = LocalTime.now();\n    System.out.println(myObj);\n  }\n}\nThe output will be:\n\n23:46:52.191340\n\nDisplay Current Date and Time\nTo display the current date and time, import the java.time.LocalDateTime class, and use its now() method:\n\nExample\nimport java.time.LocalDateTime; // import the LocalDateTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myObj = LocalDateTime.now();\n    System.out.println(myObj);\n  }\n}\nThe output will be:\n\n2024-05-19T23:46:52.191138\n\nFormatting Date and Time\nThe \"T\" in the example above is used to separate the date from the time. You can use the DateTimeFormatter class with the ofPattern() method in the same package to format or parse date-time objects. The following example will remove both the \"T\" and nanoseconds from the date-time:\n\nExample\nimport java.time.LocalDateTime; // Import the LocalDateTime class\nimport java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myDateObj = LocalDateTime.now();\n    System.out.println(\"Before formatting: \" + myDateObj);\n    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\n    String formattedDate = myDateObj.format(myFormatObj);\n    System.out.println(\"After formatting: \" + formattedDate);\n  }\n}\nThe output will be:\n\nBefore Formatting: 2024-05-19T23:46:52.192181\nAfter Formatting: 19-05-2024 23:46:52\n\nThe ofPattern() method accepts all sorts of values, if you want to display the date and time in a different format. For example:\n\nValue\tExample\nyyyy-MM-dd\t\"1988-09-29\"\ndd/MM/yyyy\t\"29/09/1988\"\ndd-MMM-yyyy\t\"29-Sep-1988\"\nE, MMM dd yyyy\t\"Thu, Sep 29 1988\""
  },
  {
    "Title": "Java ArrayList",
    "Info": "Java ArrayList\nThe ArrayList class is a resizable array, which can be found in the java.util package.\n\nThe difference between a built-in array and an ArrayList in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an ArrayList whenever you want. The syntax is also slightly different:\n\nExample\nCreate an ArrayList object called cars that will store strings:\n\nimport java.util.ArrayList; // import the ArrayList class\n\nArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nAdd Items\nThe ArrayList class has many useful methods. For example, to add elements to the ArrayList, use the add() method:\n\nExample\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\nAccess an Item\nTo access an element in the ArrayList, use the get() method and refer to the index number:\n\nExample\ncars.get(0);\n\nRemember: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\n\nChange an Item\nTo modify an element, use the set() method and refer to the index number:\n\nExample\ncars.set(0, \"Opel\");\n\nRemove an Item\nTo remove an element, use the remove() method and refer to the index number:\n\nExample\ncars.remove(0);\n\nTo remove all the elements in the ArrayList, use the clear() method:\n\nExample\ncars.clear();\n\nArrayList Size\nTo find out how many elements an ArrayList have, use the size method:\n\nExample\ncars.size();\n\nLoop Through an ArrayList\nLoop through the elements of an ArrayList with a for loop, and use the size() method to specify how many times the loop should run:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (int i = 0; i < cars.size(); i++) {\n      System.out.println(cars.get(i));\n    }\n  }\n}\n\nYou can also loop through an ArrayList with the for-each loop:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nOther Types\nElements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nExample\nCreate an ArrayList to store numbers (add elements of type Integer):\n\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(10);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(25);\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nSort an ArrayList\nAnother useful class in the java.util package is the Collections class, which include the sort() method for sorting lists alphabetically or numerically:\n\nExample\nSort an ArrayList of Strings:\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    Collections.sort(cars);  // Sort cars\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nExample\nSort an ArrayList of Integers:\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers);  // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}"
  },
  {
    "Title": "Java LinkedList",
    "Info": "Java LinkedList\nIn the previous chapter, you learned about the ArrayList class. The LinkedList class is almost identical to the ArrayList:\n\nExample\n// Import the LinkedList class\nimport java.util.LinkedList;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedList<String> cars = new LinkedList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\nArrayList vs. LinkedList\nThe LinkedList class is a collection which can contain many objects of the same type, just like the ArrayList.\n\nThe LinkedList class has all of the same methods as the ArrayList class because they both implement the List interface. This means that you can add items, change items, remove items and clear the list in the same way.\n\nHowever, while the ArrayList class and the LinkedList class can be used in the same way, they are built very differently.\n\nHow the ArrayList works\nThe ArrayList class has a regular array inside it. When an element is added, it is placed into the array. If the array is not big enough, a new, larger array is created to replace the old one and the old one is removed.\n\nHow the LinkedList works\nThe LinkedList stores its items in \"containers.\" The list has a link to the first container and each container has a link to the next container in the list. To add an element to the list, the element is placed into a new container and that container is linked to one of the other containers in the list.\n\nWhen To Use\nUse an ArrayList for storing and accessing data, and LinkedList to manipulate data.\n\nLinkedList Methods\nFor many cases, the ArrayList is more efficient as it is common to need access to random items in the list, but the LinkedList provides several methods to do certain operations more efficiently:\n\nMethod\tDescription\naddFirst()\tAdds an item to the beginning of the list.\naddLast()\tAdd an item to the end of the list\nremoveFirst()\tRemove an item from the beginning of the list.\nremoveLast()\tRemove an item from the end of the list\ngetFirst()\tGet the item at the beginning of the list\ngetLast()\tGet the item at the end of the list"
  },
  {
    "Title": "Java HashMap",
    "Info": "Java HashMap\nIn the ArrayList chapter, you learned that Arrays store items as an ordered collection, and you have to access them with an index number (int type). A HashMap however, store items in \"key/value\" pairs, and you can access them by an index of another type (e.g. a String).\n\nOne object is used as a key (index) to another object (value). It can store different types: String keys and Integer values, or the same type, like: String keys and String values:\n\nExample\nCreate a HashMap object called capitalCities that will store String keys and String values:\n\nimport java.util.HashMap; // import the HashMap class\n\nHashMap<String, String> capitalCities = new HashMap<String, String>();\n\nAdd Items\nThe HashMap class has many useful methods. For example, to add items to it, use the put() method:\n\nExample\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a HashMap object called capitalCities\n    HashMap<String, String> capitalCities = new HashMap<String, String>();\n\n    // Add keys and values (Country, City)\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"Germany\", \"Berlin\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"USA\", \"Washington DC\");\n    System.out.println(capitalCities);\n  }\n}\n\nAccess an Item\nTo access a value in the HashMap, use the get() method and refer to its key:\n\nExample\ncapitalCities.get(\"England\");\n\nRemove an Item\nTo remove an item, use the remove() method and refer to the key:\n\nExample\ncapitalCities.remove(\"England\");\n\nTo remove all items, use the clear() method:\n\nExample\ncapitalCities.clear();\n\nHashMap Size\nTo find out how many items there are, use the size() method:\n\nExample\ncapitalCities.size();\n\nLoop Through a HashMap\nLoop through the items of a HashMap with a for-each loop.\n\nNote: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:\n\nExample\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n\nExample\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n\nExample\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\n\nOther Types\nKeys and values in a HashMap are actually objects. In the examples above, we used objects of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nExample\nCreate a HashMap object called people that will store String keys and Integer values:\n\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashMap object called people\n    HashMap<String, Integer> people = new HashMap<String, Integer>();\n\n\n    // Add keys and values (Name, Age)\n    people.put(\"John\", 32);\n    people.put(\"Steve\", 30);\n    people.put(\"Angie\", 33);\n\n    for (String i : people.keySet()) {\n      System.out.println(\"key: \" + i + \" value: \" + people.get(i));\n    }\n  }\n}"
  },
  {
    "Title": "Java HashSet",
    "Info": "Java HashSet\nA HashSet is a collection of items where every item is unique, and it is found in the java.util package:\n\nExample\nCreate a HashSet object called cars that will store strings:\n\nimport java.util.HashSet; // Import the HashSet class\n\nHashSet<String> cars = new HashSet<String>();\n\nAdd Items\nThe HashSet class has many useful methods. For example, to add items to it, use the add() method:\n\nExample\n// Import the HashSet class\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    HashSet<String> cars = new HashSet<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\nNote: In the example above, even though BMW is added twice it only appears once in the set because every item in a set has to be unique.\n\nCheck If an Item Exists\nTo check whether an item exists in a HashSet, use the contains() method:\n\nExample\ncars.contains(\"Mazda\");\n\nRemove an Item\nTo remove an item, use the remove() method:\n\nExample\ncars.remove(\"Volvo\");\n\nTo remove all items, use the clear() method:\n\nExample\ncars.clear();\n\nHashSet Size\nTo find out how many items there are, use the size method:\n\nExample\ncars.size();\n\nLoop Through a HashSet\nLoop through the items of an HashSet with a for-each loop:\n\nExample\nfor (String i : cars) {\n  System.out.println(i);\n}\n\nOther Types\nItems in an HashSet are actually objects. In the examples above, we created items (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nExample\nUse a HashSet that stores Integer objects:\n\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashSet object called numbers\n    HashSet<Integer> numbers = new HashSet<Integer>();\n\n    // Add values to the set\n    numbers.add(4);\n    numbers.add(7);\n    numbers.add(8);\n\n    // Show which numbers between 1 and 10 are in the set\n    for(int i = 1; i <= 10; i++) {\n      if(numbers.contains(i)) {\n        System.out.println(i + \" was found in the set.\");\n      } else {\n        System.out.println(i + \" was not found in the set.\");\n      }\n    }\n  }\n}"
  },
  {
    "Title": "Java Iterator",
    "Info": "Java Iterator\nAn Iterator is an object that can be used to loop through collections, like ArrayList and HashSet. It is called an \"iterator\" because \"iterating\" is the technical term for looping.\n\nTo use an Iterator, you must import it from the java.util package.\n\nGetting an Iterator\nThe iterator() method can be used to get an Iterator for any collection:\n\nExample\n// Import the ArrayList class and the Iterator class\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Make a collection\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    // Get the iterator\n    Iterator<String> it = cars.iterator();\n\n    // Print the first item\n    System.out.println(it.next());\n  }\n}\n\nLooping Through a Collection\nTo loop through a collection, use the hasNext() and next() methods of the Iterator:\n\nExample\nwhile(it.hasNext()) {\n  System.out.println(it.next());\n}\n\nRemoving Items from a Collection\nIterators are designed to easily change the collections that they loop through. The remove() method can remove items from a collection while looping.\n\nExample\nUse an iterator to remove numbers less than 10 from a collection:\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(12);\n    numbers.add(8);\n    numbers.add(2);\n    numbers.add(23);\n    Iterator<Integer> it = numbers.iterator();\n    while(it.hasNext()) {\n      Integer i = it.next();\n      if(i < 10) {\n        it.remove();\n      }\n    }\n    System.out.println(numbers);\n  }\n}"
  },
  {
    "Title": "Java Exceptions",
    "Info": "Java Exceptions\nWhen executing Java code, different errors can occur: coding errors made by the programmer, errors due to wrong input, or other unforeseeable things.\n\nWhen an error occurs, Java will normally stop and generate an error message. The technical term for this is: Java will throw an exception (throw an error).\n\nJava try and catch\nThe try statement allows you to define a block of code to be tested for errors while it is being executed.\n\nThe catch statement allows you to define a block of code to be executed, if an error occurs in the try block.\n\nThe try and catch keywords come in pairs:\n\nSyntax\ntry {\n  //  Block of code to try\n}\ncatch(Exception e) {\n  //  Block of code to handle errors\n}\nConsider the following example:\n\nThis will generate an error, because myNumbers[10] does not exist.\n\npublic class Main {\n  public static void main(String[ ] args) {\n    int[] myNumbers = {1, 2, 3};\n    System.out.println(myNumbers[10]); // error!\n  }\n}\nThe output will be something like this:\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 10\n        at Main.main(Main.java:4)\nIf an error occurs, we can use try...catch to catch the error and execute some code to handle it:\n\nExample\npublic class Main {\n  public static void main(String[ ] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    }\n  }\n}\n\nThe output will be:\n\nSomething went wrong.\n\nFinally\nThe finally statement lets you execute code, after try...catch, regardless of the result:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    } finally {\n      System.out.println(\"The 'try catch' is finished.\");\n    }\n  }\n}\n\nThe output will be:\n\nSomething went wrong.\nThe 'try catch' is finished."
  },
  {
    "Title": "Java Threads",
    "Info": "Java Threads\nThreads allows a program to operate more efficiently by doing multiple things at the same time.\n\nThreads can be used to perform complicated tasks in the background without interrupting the main program.\n\nCreating a Thread\nThere are two ways to create a thread.\n\nIt can be created by extending the Thread class and overriding its run() method:\n\nExtend Syntax\npublic class Main extends Thread {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\nAnother way to create a thread is to implement the Runnable interface:\n\nImplement Syntax\npublic class Main implements Runnable {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\n\nRunning Threads\nIf the class extends the Thread class, the thread can be run by creating an instance of the class and call its start() method:\n\nExtend Example\npublic class Main extends Thread {\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\n\nIf the class implements the Runnable interface, the thread can be run by passing an instance of the class to a Thread object's constructor and then calling the thread's start() method:\n\nImplement Example\npublic class Main implements Runnable {\n  public static void main(String[] args) {\n    Main obj = new Main();\n    Thread thread = new Thread(obj);\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\n\nDifferences between \"extending\" and \"implementing\" Threads\nThe major difference is that when a class extends the Thread class, you cannot extend any other class, but by implementing the Runnable interface, it is possible to extend from another class as well, like: class MyClass extends OtherClass implements Runnable.\n\nConcurrency Problems\nBecause threads run at the same time as other parts of the program, there is no way to know in which order the code will run. When the threads and main program are reading and writing the same variables, the values are unpredictable. The problems that result from this are called concurrency problems.\n\nExample\nA code example where the value of the variable amount is unpredictable:\n\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(amount);\n    amount++;\n    System.out.println(amount);\n  }\n\n  public void run() {\n    amount++;\n  }\n}\n\nTo avoid concurrency problems, it is best to share as few attributes between threads as possible. If attributes need to be shared, one possible solution is to use the isAlive() method of the thread to check whether the thread has finished running before using any attributes that the thread can change.\n\nExample\nUse isAlive() to prevent concurrency problems:\n\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    // Wait for the thread to finish\n    while(thread.isAlive()) {\n      System.out.println(\"Waiting...\");\n    }\n    // Update amount and print its value\n    System.out.println(\"Main: \" + amount);\n    amount++;\n    System.out.println(\"Main: \" + amount);\n  }\n  public void run() {\n    amount++;\n  }\n}"
  },
  {
    "Title": "Java Lambda Expressions",
    "Info": "Java Lambda Expressions\nLambda Expressions were added in Java 8.\n\nA lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.\n\nSyntax\nThe simplest lambda expression contains a single parameter and an expression:\n\nparameter -> expression\nTo use more than one parameter, wrap them in parentheses:\n\n(parameter1, parameter2) -> expression\nExpressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement.\n\n(parameter1, parameter2) -> { code block }\n\nUsing Lambda Expressions\nLambda expressions are usually passed as parameters to a function:\n\nExample\nUse a lambda expression in the ArrayList's forEach() method to print every item in the list:\n\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    numbers.forEach( (n) -> { System.out.println(n); } );\n  }\n}\n\nLambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the Consumer interface (found in the java.util package) used by lists.\n\nExample\nUse Java's Consumer interface to store a lambda expression in a variable:\n\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    Consumer<Integer> method = (n) -> { System.out.println(n); };\n    numbers.forEach( method );\n  }\n}\n\nTo use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:\n\nExample\nCreate a method which takes a lambda expression as a parameter:\n\ninterface StringFunction {\n  String run(String str);\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    StringFunction exclaim = (s) -> s + \"!\";\n    StringFunction ask = (s) -> s + \"?\";\n    printFormatted(\"Hello\", exclaim);\n    printFormatted(\"Hello\", ask);\n  }\n  public static void printFormatted(String str, StringFunction format) {\n    String result = format.run(str);\n    System.out.println(result);\n  }\n}"
  },
  {
    "Title": "Java Methods",
    "Info": "A method is a block of code which only runs when it is called.\n\nYou can pass data, known as parameters, into a method.\n\nMethods are used to perform certain actions, and they are also known as functions.\n\nWhy use methods? To reuse code: define the code once, and use it many times.\n\nCreate a Method\nA method must be declared within a class. It is defined with the name of the method, followed by parentheses (). Java provides some pre-defined methods, such as System.out.println(), but you can also create your own methods to perform certain actions:\n\nExample\nCreate a method inside Main:\n\npublic class Main {\n  static void myMethod() {\n    // code to be executed\n  }\n}\n\nExample Explained\nmyMethod() is the name of the method\nstatic means that the method belongs to the Main class and not an object of the Main class. You will learn more about objects and how to access methods through objects later in this tutorial.\nvoid means that this method does not have a return value. You will learn more about return values later in this chapter\n\nCall a Method\nTo call a method in Java, write the method's name followed by two parentheses () and a semicolon;\n\nIn the following example, myMethod() is used to print a text (the action), when it is called:\n\nExample\nInside main, call the myMethod() method:\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"I just got executed!\"\n\nA method can also be called multiple times:\n\nExample\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n    myMethod();\n    myMethod();\n  }\n}\n\n// I just got executed!\n// I just got executed!\n// I just got executed!\n\nIn the next chapter, Method Parameters, you will learn how to pass data (parameters) into a method.\n\nTest Yourself With Exercises\nExercise:\nInsert the missing part to call myMethod from main.\n\nstatic void myMethod() {\n  System.out.println(\"I just got executed!\");\n}\n\npublic static void main(String[] args) {\n  myMethod();\n}"
  },
  {
    "Title": "Java Method Parameters",
    "Info": "Parameters and Arguments\nInformation can be passed to methods as parameters. Parameters act as variables inside the method.\n\nParameters are specified after the method name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.\n\nThe following example has a method that takes a String called fname as parameter. When the method is called, we pass along a first name, which is used inside the method to print the full name:\n\nExample\npublic class Main {\n  static void myMethod(String fname) {\n    System.out.println(fname + \" Refsnes\");\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\");\n    myMethod(\"Jenny\");\n    myMethod(\"Anja\");\n  }\n}\n// Liam Refsnes\n// Jenny Refsnes\n// Anja Refsnes"
  },
  {
    "Title": "Java Return",
    "Info": "Return Values\nIn the previous page, we used the void keyword in all examples, which indicates that the method should not return a value.\n\nIf you want the method to return a value, you can use a primitive data type (such as int, char, etc.) instead of void, and use the return keyword inside the method:\n\nExample\npublic class Main {\n  static int myMethod(int x) {\n    return 5 + x;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(3));\n  }\n}\n// Outputs 8 (5 + 3)\n\nThis example returns the sum of a method's two parameters:\n\nExample\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(5, 3));\n  }\n}\n// Outputs 8 (5 + 3)\n\nYou can also store the result in a variable (recommended, as it is easier to read and maintain):\n\nExample\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    int z = myMethod(5, 3);\n    System.out.println(z);\n  }\n}\n// Outputs 8 (5 + 3)"
  },
  {
    "Title": "Java Method Overloading",
    "Info": "Method Overloading\nWith method overloading, multiple methods can have the same name with different parameters:\n\nExample\nint myMethod(int x)\nfloat myMethod(float x)\ndouble myMethod(double x, double y)\n\nConsider the following example, which has two methods that add numbers of different type:\n\nExample\nstatic int plusMethodInt(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethodDouble(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethodInt(8, 5);\n  double myNum2 = plusMethodDouble(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}\n\nInstead of defining two methods that should do the same thing, it is better to overload one.\n\nIn the example below, we overload the plusMethod method to work for both int and double:\n\nExample\nstatic int plusMethod(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethod(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethod(8, 5);\n  double myNum2 = plusMethod(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}"
  },
  {
    "Title": "Java Scope",
    "Info": "In Java, variables are only accessible inside the region they are created. This is called scope.\n\nMethod Scope\nVariables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    int x = 100;\n\n    // Code here can use x\n    System.out.println(x);\n  }\n}\n\nBlock Scope\nA block of code refers to all of the code between curly braces {}.\n\nVariables declared inside blocks of code are only accessible by the code between the curly braces, which follows the line in which the variable was declared:\n\nExample\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    { // This is a block\n\n      // Code here CANNOT use x\n\n      int x = 100;\n\n      // Code here CAN use x\n      System.out.println(x);\n\n    } // The block ends here\n\n  // Code here CANNOT use x\n\n  }\n}"
  },
  {
    "Title": "Java Recursion",
    "Info": "Recursion is the technique of making a function call itself. This technique provides a way to break complicated problems down into simple problems which are easier to solve.\n\nRecursion may be a bit difficult to understand. The best way to figure out how it works is to experiment with it.\n\nRecursion Example\nAdding two numbers together is easy to do, but adding a range of numbers is more complicated. In the following example, recursion is used to add a range of numbers together by breaking it down into the simple task of adding two numbers:\n\nExample\nUse recursion to add all of the numbers up to 10.\n\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(10);\n    System.out.println(result);\n  }\n  public static int sum(int k) {\n    if (k > 0) {\n      return k + sum(k - 1);\n    } else {\n      return 0;\n    }\n  }\n}\n\nExample Explained\nWhen the sum() function is called, it adds parameter k to the sum of all numbers smaller than k and returns the result. When k becomes 0, the function just returns 0. When running, the program follows these steps:\n\n10 + sum(9)\n10 + ( 9 + sum(8) )\n10 + ( 9 + ( 8 + sum(7) ) )\n...\n10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + sum(0)\n10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0\nSince the function does not call itself when k is 0, the program stops there and returns the result.\n\nHalting Condition\nJust as loops can run into the problem of infinite looping, recursive functions can run into the problem of infinite recursion. Infinite recursion is when the function never stops calling itself. Every recursive function should have a halting condition, which is the condition where the function stops calling itself. In the previous example, the halting condition is when the parameter k becomes 0.\n\nIt is helpful to see a variety of different examples to better understand the concept. In this example, the function adds a range of numbers between a start and an end. The halting condition for this recursive function is when end is not greater than start:\n\nExample\nUse recursion to add all of the numbers between 5 to 10.\n\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(5, 10);\n    System.out.println(result);\n  }\n  public static int sum(int start, int end) {\n    if (end > start) {\n      return end + sum(start, end - 1);\n    } else {\n      return end;\n    }\n  }\n}"
  }
]